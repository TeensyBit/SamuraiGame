# Background

I am a budding embedded systems developer with a profound passion for low-level hardware. I enjoy writing bare-metal embedded drivers for various MCUs and peripheral devices. When I tried web development for the first time, I found it to be too monotonous. Tasked with creating a project for the course, I contemplated the ubiquitous choice of developing a portfolio website. As a beginner trying to build a website with HTML, CSS, and JS, the process of designing and fine-tuning the layout was tedious and cumbersome. Seeking a more intellectually stimulating challenge, I tried game development with JS. Shadow Fight and Mortal Kombat are two games I played the most as a kid. The noob I am in game dev, I tried replicating a samurai fight game.  

# Documentation
## index.html
The index.html file represents the structural framework for a samurai fighting game interface. Within the <head> section, pre-connect links are established for Google Fonts, followed by the inclusion of the 'Press Start 2P' font via a stylesheet link. Inline CSS styles are employed to ensure consistency across elements, enforcing the chosen font and box-sizing property. The <body> section encapsulates the game elements, enclosed within a main container div. This container orchestrates components such as player and enemy health bars, a timer display, and a canvas for graphics rendering. Each health bar comprises a red background indicating health depletion and a dynamic progress indicator. The timer display showcases the remaining time for player actions. An area for displaying game outcomes is included but initially hidden. Lastly, external JavaScript dependencies, including the GreenSock Animation Platform (GSAP) library, are imported, along with custom JavaScript files responsible for game logic. 

## index.js
The index.js file drives the core functionality of the game. Upon initializing the canvas and rendering context, the script establishes the game environment and key elements such as background scenery and a shop sprite. Two fighters, representing the player character and an enemy, are instantiated with various attributes and sprite animations sourced from image files. Central to the game's operation is the animate() function, responsible for orchestrating continuous updates and rendering of game elements while managing player input and interactions. Event listeners enable responsive movement controls for both the player and enemy fighters, ensuring character animations and gameplay. Additionally, collision detection logic facilitates the detection and resolution of interactions between fighters, including attacks and health adjustments. 

## classes.js
The Sprite class is the blueprint for creating sprite objects within the samurai fighting game. Upon instantiation, it initializes properties such as position, image source, scale, maximum frames for animation, and offset. Methods within the class handle the drawing of the sprite on the canvas and the animation of its frames. The update() method orchestrates the overall update process for the sprite, ensuring its appearance and animations are correctly rendered.

Extending the Sprite class, the Fighter class represents the player character and enemy fighters. It inherits properties and methods from Sprite while introducing additional attributes specific to fighters, including velocity, color, and attack box details. The class methods facilitate fighter updates, attacks, taking hits, and switching sprite animations based on game events. Through comprehensive documentation, both classes provide a structured foundation for managing sprite rendering, animation, and fighter behavior within the samurai fighting game.

## utils.js
The rectangularCollision() function determines whether two rectangles, represented by rectangle1 and rectangle2, are colliding with each other. It calculates the collision by comparing the positions and dimensions of the attack boxes associated with the rectangles. If a collision occurs, the function returns true; otherwise, it returns false.
The determineWinner() function is responsible for determining the winner of the samurai fighting game based on the health of the player and the enemy. It clears the timer using the provided timerId, displays the game outcome on the screen, and updates the #displayText element accordingly. If both players have equal health, the game is declared a tie. Otherwise, the player with higher health is declared the winner.
Additionally, there's a timer functionality implemented in the decreaseTimer() function. This function decrements the timer value by 1 every second until it reaches zero, updating the displayed timer on the screen. Upon reaching zero, it calls the determineWinner() function to declare the winner based on the remaining health of the player and the enemy.

